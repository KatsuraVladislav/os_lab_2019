_________________________________________________________________________

			Лаба 5

	Состояние гонки (англ. race condition), также конкуренция[1] — ошибка проектирования многопоточной системы или приложения, при которой работа системы или приложения зависит от того, в каком порядке выполняются части кода. Своё название ошибка получила от похожей ошибки проектирования электронных схем .
Возможные последствия
	Из-за неконтролируемого доступа к общей памяти состояние гонки может приводить к совершенно различным ошибкам, которые могут проявляться в непредсказуемые моменты времени, а попытка повторения ошибки в целях отладки со схожими условиями работы может оказаться безуспешной.
Основными последствиями могут быть:
	утечки памяти
	ошибки сегментирования,
	порча данных
	уязвимости
	взаимные блокировки,
	утечки других ресурсов, например файловых дескрипторов.

	Критическая секция — участок исполняемого кода программы, в котором производится доступ к общему ресурсу (данным или устройству), который не должен быть одновременно использован более чем одним потоком выполнения. При нахождении в критической секции двух (или более) потоков возникает состояние «гонки» («состязания»). Для избежания данной ситуации необходимо выполнение четырех условий:
	Два потока не должны одновременно находиться в критических областях.
В программе не должно быть предположений о скорости или количестве процессоров.
Поток, находящийся вне критической области, не может блокировать другие потоки.
Невозможна ситуация, в которой поток вечно ждет попадания в критическую область.

	Мьютекс (англ. mutex, от mutual exclusion — «взаимное исключение») — это базовый механизм синхронизации. Он предназначен для организации взаимоисключающего доступа к общим данным для нескольких потоков с использованием барьеров памяти (для простоты можно считать мьютекс дверью, ведущей к общим данным).
	Перед использованием необходимо инициализировать мьютекс функцией pthread_mutex_init
	int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr);
После использования мьютекса его необходимо уничтожить с помощью функции
	int pthread_mutex_destroy(pthread_mutex_t *mutex);
После создания мьютекса он может быть захвачен с помощью функции
	int pthread_mutex_lock(pthread_mutex_t *mutex);
Освобождение должен провести поток, заблокировавший мьютекс, вызовом
	int pthread_mutex_unlock(pthread_mutex_t *mutex);

	Взаи́мная блокиро́вка (сокращённо взаимоблокировка, англ. deadlock) — ситуация в многозадачной среде или СУБД, при которой несколько процессов находятся в состоянии ожидания ресурсов, занятых друг другом, и ни один из них не может продолжать свое выполнение.
